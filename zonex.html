<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zone X - Persistente Items</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #050510; 
            color: #E0E0E0; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
        }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 15px;
            left: 15px;
            padding: 12px 18px;
            background-color: rgba(10, 20, 40, 0.75); 
            border: 1px solid rgba(0, 180, 255, 0.6); 
            border-radius: 8px; 
            color: #00E5FF; 
            opacity: 0.9; 
            font-size: 0.7em; 
            text-shadow: 0 0 5px rgba(0, 200, 255, 0.7); 
            box-shadow: 0 0 15px rgba(0, 150, 255, 0.3); 
            z-index: 10;
            line-height: 1.4;
        }
        #info br {
            content: "";
            margin: 3px 0;
            display: block;
        }
        .info-line { 
            margin-bottom: 4px;
        }
        .overlay-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(5, 5, 20, 0.92); 
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 2000; 
            cursor: pointer; 
        }
        #startScreenText {
            font-size: 7em; 
            color: #00FF99; 
            font-weight: bold;
            letter-spacing: 2px;
            text-shadow: 0 0 8px #00FF99, 0 0 15px #00DD88, 0 0 25px #00AA66, 0 0 40px #007744;
            animation: pulseStartStylish 1.2s infinite alternate;
            opacity: 0; 
            transition: opacity 0.5s ease-in-out; 
        }
        #gameOverScreen {
             display: none; 
        }
        #gameOverText {
            font-size: 6em; 
            color: #FF2222; 
            font-weight: bold;
            letter-spacing: 1px;
            text-shadow: 0 0 8px #FF2222, 0 0 15px #DD0000, 0 0 25px #AA0000, 0 0 40px #770000; 
            animation: pulseGameOverStylish 1.5s infinite alternate;
        }

        @keyframes pulseGameOverStylish {
            from { transform: scale(1); opacity: 0.85; filter: brightness(0.9); }
            to { transform: scale(1.03); opacity: 1; filter: brightness(1.1); }
        }
        @keyframes pulseStartStylish {
            from { transform: scale(1); opacity: 0.75; filter: brightness(0.9); }
            to { transform: scale(1.02); opacity: 1; filter: brightness(1.1); }
        }
    </style>
</head>
<body>
    <div id="info">
        <div class="info-line">ZONE X</div>
        <div class="info-line">Steuerung: Maus & Klick. Mausrad: Zoom.</div>
        <div class="info-line">Ziel: Schlüssel zu Truhen, dann Exit.</div>
        <div class="info-line" id="livesInfo">Leben: 3 / 3</div>
        <div class="info-line" id="keysInfo">Schlüssel: 0 | Ziel: 0</div>
        <div class="info-line" id="chestsInfo">Abgelegt: 0 / 0</div>
    </div>
    
    <div id="startScreen" class="overlay-screen">
        <div id="startScreenText">ZONE X</div>
    </div>
    <div id="gameOverScreen" class="overlay-screen">
        <div id="gameOverText">GAME OVER</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js",
                "tone": "https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        
        let Tone; 
        try {
            const importedModule = await import('tone');
            if (importedModule.default && typeof importedModule.default.Synth === 'function') {
                Tone = importedModule.default;
            } else if (importedModule.Tone && typeof importedModule.Tone.Synth === 'function') { 
                Tone = importedModule.Tone;
            } else if (importedModule && typeof importedModule.Synth === 'function') {
                Tone = importedModule;
            } else if (window.Tone && typeof window.Tone.Synth === 'function') {
                Tone = window.Tone;
            } else {
                Tone = null;
            }
        } catch (e) {
            console.warn("Tone.js could NOT be loaded via import. Sounds will be disabled.", e);
            Tone = null;
        }

        // Globale Spielvariablen
        let scene, camera, renderer, sphereMesh, raycaster, mouse, ambientLight, sphereGroup, starField;
        let gameTriangles = []; 
        let playerTriangleId = -1;
        let hoveredTriangleId = -1;
        let targetSphereQuaternion = new THREE.Quaternion();
        const sphereRadius = 10;
        const subdivisions = 4; 

        const PLAYER_MOVE_COOLDOWN = 0; 
        const ENEMY_MOVE_COOLDOWN = 500; 
        let lastPlayerMoveTime = 0;
        let enemies = []; 


        // Spielstatus
        let playerLives = 3; 
        const MAX_PLAYER_LIVES = 3; 
        
        let _numKeys = 0; 
        Object.defineProperty(window, 'numKeys', { 
            get: () => _numKeys,
            set: (value) => {
                _numKeys = value;
            }
        });
        numKeys = 0; 

        let _numChests = 0;
        Object.defineProperty(window, 'numChests', {
            get: () => _numChests,
            set: (value) => {
                _numChests = value;
            }
        });
        numChests = 0;

        let _playerKeysHeld = 0;
        Object.defineProperty(window, 'playerKeysHeld', {
            get: () => _playerKeysHeld,
            set: (value) => {
                _playerKeysHeld = value;
            }
        });
        playerKeysHeld = 0;

        let _keysDelivered = 0;
        Object.defineProperty(window, 'keysDelivered', {
            get: () => _keysDelivered,
            set: (value) => {
                _keysDelivered = value;
            }
        });
        keysDelivered = 0;
        
        let startLocationId = -1; 
        let exitLocationId = -1;  
        let gameOver = false; 
        let gameActive = false; 
        let startScreenTimeout; 
        let startScreenActive = true; 

        // Farben - Futuristisch
        const COLOR_DEFAULT = new THREE.Color(0x1A1A2E); 
        const COLOR_PLAYER = new THREE.Color(0x00FFAA);   
        const COLOR_WALL = new THREE.Color(0x4B527E);     
        const COLOR_ENEMY = new THREE.Color(0xFF4136);    
        const COLOR_KEY = new THREE.Color(0xFFDC00);      
        const COLOR_CHEST = new THREE.Color(0xA040A0);    
        const COLOR_CHEST_USED = new THREE.Color(0x7A297A); 
        const COLOR_START = new THREE.Color(0x7FDBFF);    
        const COLOR_EXIT = new THREE.Color(0xF012BE);     
        const COLOR_PATH_HIGHLIGHT = new THREE.Color(0x00BFFF); 
        const COLOR_HOVER_HIGHLIGHT = new THREE.Color(0x00FFFF); 
        const COLOR_BACKGROUND_FLASH = new THREE.Color(0xAA4444); 
        const ORIGINAL_BACKGROUND_COLOR = new THREE.Color(0x050510); 
        const COLOR_WARP_OUT_PLAYER = new THREE.Color(0x00FFFF); 
        const COLOR_WARP_IN_PLAYER = new THREE.Color(0xAAFFEE); 
        const COLOR_WARP_OUT_ENEMY = new THREE.Color(0xAA0000); 
        const COLOR_WARP_IN_ENEMY = new THREE.Color(0xFF8888); 
        const COLOR_ENEMY_ARROW = new THREE.Color(0xF0F0F0); 
        
        // Pathfinding & Auto-Move Variablen
        let isAutoMoving = false; 
        let autoMovePath = [];    
        let nextAutoMoveTime = 0; 
        const PATH_HIGHLIGHT_DURATION = 20; 

        // Soundeffekte
        let audioContextStarted = false; 
        let hoverSynth, moveSynth, keyPickupSynth, chestDeliverySynth, winSynth, loseSynth, pathStartSynth, wallHitSynth, pathCancelSynth, errorSynth, lifeLostSynth, startScreenSynth;

        // Zoom Variablen
        const MIN_ZOOM_DISTANCE = sphereRadius * 1.1; 
        const MAX_ZOOM_DISTANCE = sphereRadius * 5;   
        const ZOOM_SPEED = 0.0005; 

        // Animationen
        const WARP_ANIM_DURATION = 60; 


        // Initialisierung
        async function init() {
            scene = new THREE.Scene();
            scene.background = ORIGINAL_BACKGROUND_COLOR.clone(); 
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, sphereRadius * 1.8); 
            camera.lookAt(scene.position); 

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight); 
            renderer.setPixelRatio(window.devicePixelRatio); 
            document.body.appendChild(renderer.domElement); 

            ambientLight = new THREE.AmbientLight(0xAAAAFF, 0.6); 
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 0.8); 
            directionalLight.position.set(8, 12, 10); 
            directionalLight.castShadow = true; 
            scene.add(directionalLight);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2(); 

            sphereGroup = new THREE.Group();
            scene.add(sphereGroup);

            if (Tone) { 
                initializeSounds(); 
            } else {
                console.warn("Sound-Initialisierung übersprungen.");
            }

            generateSphere(); 
            createStarfield();  
            generateLevel();    
            updateTriangleColors(); 

            renderer.render(scene, camera); 

            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('click', onLeftMouseClick, false); 
            document.addEventListener('mousedown', onDocumentMouseDown, false);
            document.addEventListener('wheel', onMouseWheel, { passive: false });
            
            updateInfoPanel();
            
            const startScreenElement = document.getElementById('startScreen');
            const startScreenTextElement = document.getElementById('startScreenText');
            
            startScreenElement.style.display = 'flex'; 
            startScreenTextElement.style.opacity = '1'; 

            startScreenElement.addEventListener('click', startGame, { once: true }); 
            startScreenTimeout = setTimeout(startGame, 10000000000); 

            animate(); 
        }

        async function startGame() {
            if (!startScreenActive) return; 
            startScreenActive = false; 

            clearTimeout(startScreenTimeout); 
            
            const startScreenElement = document.getElementById('startScreen');
            startScreenElement.style.display = 'none'; 
            
            if (Tone) await ensureAudioContextStarted(); 
            playSound(startScreenSynth, ["C4", "G4", "C5", "E5"], "1n"); 
            
            gameActive = true; 

            if (playerTriangleId !== -1 && gameTriangles[playerTriangleId]) { 
                const playerTriangle = gameTriangles[playerTriangleId];
                if (playerTriangle.center) { 
                    const targetDir = playerTriangle.center.clone().normalize();
                    targetSphereQuaternion.setFromUnitVectors(new THREE.Vector3(0,0,1), targetDir).invert();
                    if (sphereGroup) sphereGroup.quaternion.copy(targetSphereQuaternion);
                }
            }
        }


        async function ensureAudioContextStarted() {
            if (!Tone || !Tone.context) return; 
            if (!audioContextStarted && Tone.context.state !== 'running') {
                try {
                    await Tone.start(); 
                    audioContextStarted = true;
                } catch (e) {
                    console.error("Error starting AudioContext:", e);
                }
            }
        }

        function initializeSounds() {
            const shortImpact = { attack: 0.001, decay: 0.08, sustain: 0, release: 0.05 };

            hoverSynth = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.002, decay: 0.03, sustain: 0, release: 0.03 }, volume: -28 }).toDestination();
            moveSynth = new Tone.Synth({ oscillator: { type: 'triangle4' }, envelope: { attack: 0.005, decay: 0.05, sustain: 0, release: 0.08 }, volume: -20 }).toDestination();
            
            keyPickupSynth = new Tone.PolySynth(Tone.Synth, {
                polyphony: 3,
                oscillator: { type: 'triangle', detune: 0 },
                envelope: { attack: 0.005, decay: 0.1, sustain: 0.05, release: 0.1 },
                volume: -12
            }).toDestination();
            
            const chestMechanismSound = new Tone.MetalSynth({ 
                frequency: 150,
                envelope: { attack: 0.001, decay: 0.1, release: 0.01 },
                harmonicity: 3.1, modulationIndex: 16, octaves: 0.5, volume: -18
            }).toDestination();
            const keysDepositedSound = new Tone.FMSynth({ 
                harmonicity: 3.01,
                modulationIndex: 10,
                detune: 0,
                oscillator: { type: "sine" },
                envelope: { attack: 0.01, decay: 0.3, sustain: 0.01, release: 0.2 },
                modulation: { type: "square" },
                modulationEnvelope: { attack: 0.02, decay: 0.2, sustain: 0, release: 0.1 },
                volume: -8
            }).toDestination();
             chestDeliverySynth = { 
                trigger: (time) => {
                    chestMechanismSound.triggerAttackRelease("32n", time);
                    keysDepositedSound.triggerAttackRelease("C5", "4n", time + 0.05); 
                }
            };

            winSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: 'fatsine', count:3, spread: 30 }, 
                envelope: { attack: 0.1, decay: 0.8, sustain: 0.2, release: 0.5 }, volume: -8 
            }).toDestination();
            
            loseSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "fatsquare", count: 4, spread: 40, detune: -200 },
                envelope: { attack: 0.02, decay: 2.0, sustain: 0, release: 0.8 }, 
                volume: -6
            }).toDestination();

            pathStartSynth = new Tone.Synth({ oscillator: { type: 'sine', detune: 50 }, envelope: shortImpact, volume: -22 }).toDestination();
            wallHitSynth = new Tone.Synth({ oscillator: { type: 'square', detune: -1500 }, envelope: { attack:0.001, decay:0.06, sustain:0, release:0.04 }, volume: -16 }).toDestination();
            pathCancelSynth = new Tone.Synth({ oscillator: { type: 'triangle', detune: -50 }, envelope: shortImpact, volume: -18 }).toDestination();
            errorSynth = new Tone.NoiseSynth({
                noise: { type: 'brown' }, 
                envelope: { attack: 0.005, decay: 0.08, sustain: 0, release: 0.08 },
                volume: -22 
            }).toDestination();
            lifeLostSynth = new Tone.Synth({
                oscillator: { type: 'fatsquare', detune: -800, count: 4, spread: 50 }, 
                envelope: { attack: 0.01, decay: 0.5, sustain: 0.05, release: 0.4 }, 
                volume: -7
            }).toDestination();
            startScreenSynth = new Tone.PolySynth(Tone.Synth, { 
                oscillator: { type: "fatsine", count: 4, spread: 25 },
                envelope: { attack: 0.1, decay: 0.5, sustain: 0.2, release: 0.3 },
                volume: -8
            }).toDestination();
        }

        function playSound(synth, noteOrTimeToTrigger, duration = "8n", time) {
            if (!Tone || !synth || !audioContextStarted) return; 
            
            const playTime = time || Tone.now(); 
            try {
                if (synth === chestDeliverySynth) { 
                    synth.trigger(playTime);
                } else if (synth instanceof Tone.NoiseSynth) { 
                     synth.triggerAttackRelease(duration, playTime);
                } else if (synth instanceof Tone.PluckSynth) { 
                     synth.triggerAttack(noteOrTimeToTrigger, playTime);
                }
                else if (synth instanceof Tone.PolySynth || synth instanceof Tone.Synth) { 
                     synth.triggerAttackRelease(noteOrTimeToTrigger, duration, playTime);
                }
            } catch (e) { /* console.warn(`Sound playback failed:`, e); */ }
        }
        
        function showMessage(text) { 
            console.log("Game Message (Dialog suppressed):", text); 
            if (text.toLowerCase().includes("kann nicht") || text.toLowerCase().includes("kein pfad") || text.toLowerCase().includes("brauchst einen schlüssel") || text.toLowerCase().includes("bereits benutzt")) {
                playSound(errorSynth, null, "16n"); 
            }
        }

        function triggerBackgroundFlash() {
            if (scene) {
                scene.background = COLOR_BACKGROUND_FLASH.clone();
                setTimeout(() => {
                    if (scene) scene.background = ORIGINAL_BACKGROUND_COLOR.clone();
                }, 120); 
            }
        }

        function createStarfield() {
            const starQty = 35000; 
            const starVertices = []; 
            const starColors = [];   

            const starMaterial = new THREE.PointsMaterial({
                size: 0.3, 
                sizeAttenuation: true, 
                color: 0xffffff,       
                vertexColors: true,    
                transparent: true,
                opacity: 0.8,          
                blending: THREE.AdditiveBlending, 
                depthWrite: false      
            });

            const starGeometry = new THREE.BufferGeometry();

            for (let i = 0; i < starQty; i++) {
                let x = THREE.MathUtils.randFloatSpread(sphereRadius * 30); 
                let y = THREE.MathUtils.randFloatSpread(sphereRadius * 30);
                let z = THREE.MathUtils.randFloatSpread(sphereRadius * 30);
                
                const distSq = x*x + y*y + z*z;
                if (distSq < (sphereRadius * 2.5) * (sphereRadius * 2.5)) { 
                    const r = sphereRadius * 2.5 + Math.random() * sphereRadius * 20;
                    const phi = Math.random() * Math.PI * 2; 
                    const theta = Math.random() * Math.PI;   
                    x = r * Math.sin(theta) * Math.cos(phi);
                    y = r * Math.sin(theta) * Math.sin(phi);
                    z = r * Math.cos(theta);
                }
                starVertices.push(x, y, z);

                const distanceFromCenter = Math.sqrt(x*x + y*y + z*z);
                const baseBrightness = 0.6 + Math.random() * 0.4; 
                const brightness = Math.max(0.2, baseBrightness * (1 - Math.min(1, distanceFromCenter / (sphereRadius * 25))));
                
                const starColor = new THREE.Color();
                if (Math.random() < 0.3) {
                    starColor.setHSL(0.6, 0.8, brightness * 0.8); 
                } else if (Math.random() < 0.6) {
                    starColor.setHSL(0.15, 0.9, brightness); 
                } else {
                    starColor.setHSL(0, 0, brightness); 
                }
                starColors.push(starColor.r, starColor.g, starColor.b);
            }

            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));

            starField = new THREE.Points(starGeometry, starMaterial);
            sphereGroup.add(starField); 
        }


        function generateSphere() {
            let vertices = []; 
            let faces = [];    

            const t = (1.0 + Math.sqrt(5.0)) / 2.0; 
            const icosahedronVerticesData = [
                [-1, t, 0], [1, t, 0], [-1, -t, 0], [1, -t, 0],
                [0, -1, t], [0, 1, t], [0, -1, -t], [0, 1, -t],
                [t, 0, -1], [t, 0, 1], [-t, 0, -1], [-t, 0, 1]
            ];
            icosahedronVerticesData.forEach(v => vertices.push(new THREE.Vector3(v[0], v[1], v[2]).normalize().multiplyScalar(sphereRadius)));

            const icosahedronFacesData = [ 
                [0, 11, 5], [0, 5, 1], [0, 1, 7], [0, 7, 10], [0, 10, 11],
                [1, 5, 9], [5, 11, 4], [11, 10, 2], [10, 7, 6], [7, 1, 8],
                [3, 9, 4], [3, 4, 2], [3, 2, 6], [3, 6, 8], [3, 8, 9],
                [4, 9, 5], [2, 4, 11], [6, 2, 10], [8, 6, 7], [9, 8, 1]
            ];
            faces = icosahedronFacesData;

            const midpointCache = new Map();
            function getMidpoint(p1Idx, p2Idx) {
                const sortedKey = `${Math.min(p1Idx, p2Idx)}_${Math.max(p1Idx, p2Idx)}`; 
                if (midpointCache.has(sortedKey)) {
                    return midpointCache.get(sortedKey); 
                }
                const v1 = vertices[p1Idx];
                const v2 = vertices[p2Idx];
                const mid = new THREE.Vector3().addVectors(v1, v2).normalize().multiplyScalar(sphereRadius);
                vertices.push(mid); 
                const newIdx = vertices.length - 1;
                midpointCache.set(sortedKey, newIdx); 
                return newIdx;
            }

            for (let i = 0; i < subdivisions; i++) {
                const newFaces = []; 
                midpointCache.clear(); 
                for (const face of faces) { 
                    const v1 = face[0], v2 = face[1], v3 = face[2];
                    const m12 = getMidpoint(v1, v2);
                    const m23 = getMidpoint(v2, v3);
                    const m31 = getMidpoint(v3, v1);
                    newFaces.push([v1, m12, m31]);
                    newFaces.push([v2, m23, m12]);
                    newFaces.push([v3, m31, m23]);
                    newFaces.push([m12, m23, m31]); 
                }
                faces = newFaces; 
            }
            
            const geometry = new THREE.BufferGeometry();
            const finalVertices = [], finalNormals = [], finalColors = [];

            faces.forEach((faceIndices, faceIdx) => {
                const vA = vertices[faceIndices[0]], vB = vertices[faceIndices[1]], vC = vertices[faceIndices[2]];
                finalVertices.push(vA.x, vA.y, vA.z, vB.x, vB.y, vB.z, vC.x, vC.y, vC.z);
                const normal = new THREE.Triangle(vA, vB, vC).getNormal(new THREE.Vector3());
                for(let i=0; i<3; i++) finalNormals.push(normal.x, normal.y, normal.z); 
                for(let i=0; i<3; i++) finalColors.push(COLOR_DEFAULT.r, COLOR_DEFAULT.g, COLOR_DEFAULT.b); 
                
                const center = new THREE.Vector3().add(vA).add(vB).add(vC).divideScalar(3); 
                gameTriangles.push({
                    id: faceIdx, vertexIndices: faceIndices, vertices: [vA, vB, vC],
                    center: center, normal: normal, type: 'EMPTY', 
                    originalColor: COLOR_DEFAULT.clone(), neighbors: [], isPathSegment: false,
                    isWarpingOut: false, isWarpingIn: false, warpTime: 0, warpingEntityType: null, // warpingEntityType hinzugefügt
                    isUsedChest: false, occupant: null // occupant hinzugefügt
                });
            });

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(finalVertices, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(finalNormals, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(finalColors, 3));
            geometry.computeVertexNormals(); 

            calculateAdjacencies();
            
            const material = new THREE.MeshPhongMaterial({ 
                vertexColors: true, 
                shininess: 40,      
                transparent: true,  
                opacity: 0.92       
            }); 
            sphereMesh = new THREE.Mesh(geometry, material);
            sphereGroup.add(sphereMesh); 
        }

        function calculateAdjacencies() {
            const edgeMap = new Map(); 
            gameTriangles.forEach(tri => {
                const vIdx = tri.vertexIndices;
                const edges = [[vIdx[0], vIdx[1]], [vIdx[1], vIdx[2]], [vIdx[2], vIdx[0]]];
                edges.forEach(edge => {
                    const key = `${Math.min(edge[0], edge[1])}_${Math.max(edge[0], edge[1])}`;
                    if (!edgeMap.has(key)) edgeMap.set(key, []); 
                    edgeMap.get(key).push(tri.id); 
                });
            });
            gameTriangles.forEach(tri => {
                const vIdx = tri.vertexIndices;
                const edges = [[vIdx[0], vIdx[1]], [vIdx[1], vIdx[2]], [vIdx[2], vIdx[0]]];
                const triNeighbors = new Set(); 
                edges.forEach(edge => {
                    const key = `${Math.min(edge[0], edge[1])}_${Math.max(edge[0], edge[1])}`;
                    if (edgeMap.has(key)) {
                        edgeMap.get(key).forEach(neighborId => {
                            if (neighborId !== tri.id) triNeighbors.add(neighborId);
                        });
                    }
                });
                tri.neighbors = Array.from(triNeighbors); 
            });
        }
        
        function createHollowWallStructure(centerId, innerRadius, wallThickness, maxWallsToPlace) {
            if (!gameTriangles[centerId] || gameTriangles[centerId].type === 'WALL') {
                return 0; 
            }

            let placedWallsThisStructure = 0;
            const occupiedByThisStructure = new Set(); 

            const innerRoomTriangles = new Set();
            let queue = [{ id: centerId, depth: 0 }];
            const visitedForRoom = new Set([centerId]);
            innerRoomTriangles.add(centerId);
            occupiedByThisStructure.add(centerId);


            while(queue.length > 0) {
                const current = queue.shift();
                if (current.depth >= innerRadius) continue;

                const currentTri = gameTriangles[current.id];
                if (currentTri && currentTri.neighbors) {
                    for (const neighborId of currentTri.neighbors) {
                        if (!visitedForRoom.has(neighborId) && gameTriangles[neighborId] && gameTriangles[neighborId].type !== 'WALL') {
                            visitedForRoom.add(neighborId);
                            innerRoomTriangles.add(neighborId);
                            occupiedByThisStructure.add(neighborId);
                            queue.push({ id: neighborId, depth: current.depth + 1 });
                        }
                    }
                }
            }
            
            const wallCandidateQueue = [];
            innerRoomTriangles.forEach(roomId => {
                const roomTri = gameTriangles[roomId];
                if (roomTri && roomTri.neighbors) {
                    roomTri.neighbors.forEach(neighborId => {
                        if (!innerRoomTriangles.has(neighborId) && gameTriangles[neighborId] && gameTriangles[neighborId].type !== 'WALL') {
                            if(!Array.from(wallCandidateQueue).find(item => item.id === neighborId)) { 
                                wallCandidateQueue.push({ id: neighborId, depth: 0 });
                            }
                        }
                    });
                }
            });
            
            const visitedForWalls = new Set();
            innerRoomTriangles.forEach(id => visitedForWalls.add(id)); 

            while(wallCandidateQueue.length > 0 && placedWallsThisStructure < maxWallsToPlace) {
                const currentWallCandidate = wallCandidateQueue.shift();
                if (visitedForWalls.has(currentWallCandidate.id)) continue;
                
                const tri = gameTriangles[currentWallCandidate.id];
                if (tri && tri.type !== 'WALL') { 
                    tri.type = 'WALL';
                    occupiedByThisStructure.add(tri.id);
                    placedWallsThisStructure++;
                    visitedForWalls.add(currentWallCandidate.id);

                    if (currentWallCandidate.depth < wallThickness - 1) {
                        tri.neighbors.forEach(neighborId => {
                            if (!visitedForWalls.has(neighborId) && !innerRoomTriangles.has(neighborId) && gameTriangles[neighborId]) {
                                 if(!Array.from(wallCandidateQueue).find(item => item.id === neighborId)) {
                                    wallCandidateQueue.push({ id: neighborId, depth: currentWallCandidate.depth + 1 });
                                 }
                            }
                        });
                    }
                }
            }
            return placedWallsThisStructure;
        }


        function generateLevel() {
            gameTriangles.forEach(tri => {
                tri.type = 'EMPTY';
                tri.occupant = null;
                tri.isUsedChest = false;
                tri.isPathSegment = false;
                tri.isWarpingIn = false;
                tri.isWarpingOut = false;
            });


            const numTotalTriangles = gameTriangles.length;
            if (numTotalTriangles === 0) return;

            const numWallsTarget = Math.floor(numTotalTriangles * 0.10); 
            let placedWallsCount = 0;
            
            window.numKeys = Math.max(1, Math.floor(numTotalTriangles / 100)); 
            window.numChests = window.numKeys;

            const occupiedByAnyStructure = new Set(); 

            let attempts = 0;
            const maxStructurePlacementAttempts = 30; 

            while (placedWallsCount < numWallsTarget && attempts < maxStructurePlacementAttempts) {
                attempts++;
                const potentialCenterIds = gameTriangles.filter(t => !occupiedByAnyStructure.has(t.id) && t.type === 'EMPTY').map(t => t.id);
                if (potentialCenterIds.length === 0) break; 

                const centerId = potentialCenterIds[Math.floor(Math.random() * potentialCenterIds.length)];
                
                const innerRadius = Math.floor(Math.random() * 3) + 2; 
                const wallThickness = 1; 
                const maxWallsForThisStructure = Math.min(70, numWallsTarget - placedWallsCount); 

                const wallsAdded = createHollowWallStructure(centerId, innerRadius, wallThickness, maxWallsForThisStructure);
                
                if (wallsAdded > 0) {
                    placedWallsCount += wallsAdded;
                    let structureQueue = [{id: centerId, depth: 0}];
                    let visitedForStructure = new Set([centerId]);
                    occupiedByAnyStructure.add(centerId);

                    while(structureQueue.length > 0){
                        const current = structureQueue.shift();
                        if(current.depth > innerRadius + wallThickness + 2) continue; 
                        gameTriangles[current.id].neighbors.forEach(nId => {
                            if(!visitedForStructure.has(nId)){
                                visitedForStructure.add(nId);
                                occupiedByAnyStructure.add(nId);
                                structureQueue.push({id: nId, depth: current.depth + 1});
                            }
                        });
                    }
                }
            }
            
            let availableTrianglesForItems = gameTriangles.filter(t => t.type === 'EMPTY').map(t => t.id);
            function getRandomAvailableItemTriangle() {
                if (availableTrianglesForItems.length === 0) return -1;
                const randIdx = Math.floor(Math.random() * availableTrianglesForItems.length);
                const triId = availableTrianglesForItems[randIdx];
                availableTrianglesForItems.splice(randIdx, 1);
                return triId;
            }

            const startId = getRandomAvailableItemTriangle();
            if (startId !== -1) {
                gameTriangles[startId].type = 'START';
                playerTriangleId = startId; 
                startLocationId = startId;  
                gameTriangles[playerTriangleId].occupant = 'PLAYER'; // Set occupant
            } else { console.error("Konnte Startpunkt nicht setzen!"); }

            const exitId = getRandomAvailableItemTriangle();
            if (exitId !== -1) {
                gameTriangles[exitId].type = 'EXIT';
                exitLocationId = exitId; 
            } else { console.error("Konnte Exitpunkt nicht setzen!"); }

            for (let i = 0; i < _numKeys; i++) { 
                const keyId = getRandomAvailableItemTriangle();
                if (keyId !== -1) gameTriangles[keyId].type = 'KEY';
                else console.warn("Konnte nicht alle Schlüssel setzen");
            }
            for (let i = 0; i < _numChests; i++) { 
                const chestId = getRandomAvailableItemTriangle();
                if (chestId !== -1) gameTriangles[chestId].type = 'CHEST';
                else console.warn("Konnte nicht alle Truhen setzen");
            }
            
            const numEnemies = Math.floor(numTotalTriangles / 200); 
            enemies = []; 
            for (let i = 0; i < numEnemies; i++) {
                const enemyId = getRandomAvailableItemTriangle();
                if (enemyId !== -1) {
                    gameTriangles[enemyId].occupant = `ENEMY_${i}`; // Set occupant
                    const enemyObject = { 
                        id: i, // Use loop index for unique enemy ID
                        currentTriangleId: enemyId, 
                        lastMoveTime: 0, 
                        currentFacingDirectionId: null, 
                        directionArrow: null,
                        previousMoveFromId: null 
                    };
                    
                    const arrowMaterial = new THREE.MeshBasicMaterial({ color: COLOR_ENEMY_ARROW, side: THREE.DoubleSide, depthTest: false });
                    const arrowShape = new THREE.Shape();
                    const arrowSize = 0.08; 
                    arrowShape.moveTo(0, arrowSize * 0.6); 
                    arrowShape.lineTo(arrowSize * 0.3, -arrowSize * 0.4);
                    arrowShape.lineTo(-arrowSize * 0.3, -arrowSize * 0.4);
                    arrowShape.closePath();
                    const arrowGeometry = new THREE.ShapeGeometry(arrowShape);
                    enemyObject.directionArrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
                    enemyObject.directionArrow.renderOrder = 1; 
                    enemyObject.directionArrow.visible = false; 
                    sphereGroup.add(enemyObject.directionArrow); 

                    enemies.push(enemyObject);
                } else { console.warn("Konnte nicht alle Gegner setzen"); }
            }
            enemies.forEach(enemy => {
                chooseNewEnemyFacingDirection(enemy, true); 
                updateEnemyArrow(enemy);
            });
            updateInfoPanel();
        }


        function updateTriangleColors(currentHoverId = -1, applyHoverEffect = false) {
            if (!sphereMesh || !sphereMesh.geometry || !sphereMesh.geometry.getAttribute('color')) return; 
            
            const colors = sphereMesh.geometry.getAttribute('color'); 
            const time = performance.now(); 

            gameTriangles.forEach(tri => {
                let baseColor;

                if (tri.isWarpingOut) { 
                    baseColor = tri.warpingEntityType === 'PLAYER' ? COLOR_WARP_OUT_PLAYER : COLOR_WARP_OUT_ENEMY;
                } else if (tri.isWarpingIn) {
                    baseColor = tri.warpingEntityType === 'PLAYER' ? COLOR_WARP_IN_PLAYER : COLOR_WARP_IN_ENEMY;
                } else if (tri.occupant === 'PLAYER') {
                    baseColor = COLOR_PLAYER;
                } else if (tri.occupant && tri.occupant.startsWith('ENEMY')) {
                    baseColor = COLOR_ENEMY;
                }
                else { 
                    switch (tri.type) {
                        case 'WALL': baseColor = COLOR_WALL; break;
                        case 'KEY': baseColor = COLOR_KEY; break;
                        case 'CHEST': 
                            baseColor = tri.isUsedChest ? COLOR_CHEST_USED : COLOR_CHEST; 
                            break;
                        case 'START': baseColor = COLOR_START; break;
                        case 'EXIT': baseColor = COLOR_EXIT; break;
                        case 'EMPTY': default: baseColor = tri.originalColor; break;
                    }
                }

                let finalColor = baseColor.clone(); 

                if (tri.isPathSegment && !tri.isWarpingIn && !tri.isWarpingOut) {
                    if (!tri.occupant && tri.type !== 'WALL') { // Pfad nicht über Spieler/Gegner/Wand
                        const pathPulse = (Math.sin(time * 0.008 + tri.id * 0.5) + 1) / 2 * 0.4 + 0.6; 
                        finalColor = COLOR_PATH_HIGHLIGHT.clone().multiplyScalar(pathPulse); 
                    }
                }

                if (applyHoverEffect && tri.id === currentHoverId && tri.type !== 'WALL' && !tri.isWarpingIn && !tri.isWarpingOut) {
                    const hoverPulse = (Math.sin(time * 0.01) + 1) / 2 * 0.3 + 0.8; 
                    finalColor = COLOR_HOVER_HIGHLIGHT.clone().multiplyScalar(hoverPulse);
                }
                
                for (let i = 0; i < 3; i++) {
                    colors.setXYZ(tri.id * 3 + i, finalColor.r, finalColor.g, finalColor.b);
                }
            });
            colors.needsUpdate = true; 
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight; 
            camera.updateProjectionMatrix(); 
            renderer.setSize(window.innerWidth, window.innerHeight); 
        }

        async function onMouseMove(event) { 
            if (gameOver) return; 
            event.preventDefault(); 
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            if (!sphereMesh) return; 
            raycaster.setFromCamera(mouse, camera); 
            const intersects = raycaster.intersectObject(sphereMesh); 

            let newHoveredId = -1; 
            if (intersects.length > 0) {
                const intersect = intersects[0]; 
                if (intersect.faceIndex !== undefined && gameTriangles[intersect.faceIndex]) { 
                    const faceIdx = intersect.faceIndex; 
                    if (gameTriangles[faceIdx].type !== 'WALL') { 
                       newHoveredId = faceIdx;
                    }
                }
            }

            if (newHoveredId !== hoveredTriangleId) {
                hoveredTriangleId = newHoveredId;
                if (gameActive && hoveredTriangleId !== -1) { 
                    if (Tone) await ensureAudioContextStarted(); 
                    playSound(hoverSynth, "C6", "64n");
                }
            }
        }

        async function onLeftMouseClick(event) { 
            if (event.button !== 0) return; 
            
            if (startScreenActive) {
                startGame(); 
                return;
            }
            
            if (gameOver || !gameActive) return; 

            if (Tone) await ensureAudioContextStarted(); 

            const currentTime = performance.now();

            if (isAutoMoving && autoMovePath.length > 0) {
                isAutoMoving = false;
                autoMovePath = [];
                clearPathHighlight();
                playSound(pathCancelSynth, "A3", "16n");
            }

            if (hoveredTriangleId === -1 || playerTriangleId === -1 || !gameTriangles[hoveredTriangleId] || !gameTriangles[playerTriangleId]) return; 
            if (hoveredTriangleId === playerTriangleId) return; 

            const targetTriangle = gameTriangles[hoveredTriangleId];
            if (targetTriangle.type === 'WALL') { 
                playSound(wallHitSynth, "C2", "32n");
                return;
            }

            const playerTri = gameTriangles[playerTriangleId];
            if (playerTri.neighbors.includes(hoveredTriangleId)) { 
                if (currentTime - lastPlayerMoveTime < PLAYER_MOVE_COOLDOWN) return; 
                const moveSuccessful = await movePlayerTo(hoveredTriangleId); 
                if (moveSuccessful) {
                    lastPlayerMoveTime = currentTime;
                }
            } else { 
                const path = findShortestPath(playerTriangleId, hoveredTriangleId);
                if (path && path.length > 0) { 
                    startAutoMove(path); 
                } else { 
                    playSound(errorSynth, null, "16n"); 
                }
            }
        }

        async function onDocumentMouseDown(event) { 
            if (gameOver || !gameActive) return; 
            if (event.button === 1) { 
                if (Tone) await ensureAudioContextStarted(); 
                if (isAutoMoving && autoMovePath.length > 0) {
                    isAutoMoving = false;
                    autoMovePath = [];
                    clearPathHighlight();
                    playSound(pathCancelSynth, "G3", "16n");
                }
            }
        }

        function onMouseWheel(event) {
            event.preventDefault(); 
            const zoomFactor = 1 - event.deltaY * ZOOM_SPEED; 
            let currentDistance = camera.position.length(); 
            let newDistance = currentDistance / zoomFactor; 
            newDistance = Math.max(MIN_ZOOM_DISTANCE, Math.min(MAX_ZOOM_DISTANCE, newDistance));
            if (currentDistance !== newDistance) {
                camera.position.normalize().multiplyScalar(newDistance);
            }
        }
        
        async function handleLifeLost(collisionSourceTriangleId) {
            if (gameOver) return; 

            playerLives--; 
            updateInfoPanel(); 
            playSound(lifeLostSynth, "F#2", "4n"); 
            triggerBackgroundFlash(); 

            if (playerLives <= 0) {
                gameOver = true;
                playSound(loseSynth, ["C2", "G1", "Eb2"], "1n"); 
                document.getElementById('gameOverScreen').style.display = 'flex'; 
                
                if (playerTriangleId !== -1 && gameTriangles[playerTriangleId]) { 
                     gameTriangles[playerTriangleId].occupant = null; // Spieler vom Feld nehmen (logisch)
                }
                playerTriangleId = -1; 
            }
        }
        
        async function moveEntityVisuals(oldTriangleId, newTriangleId, entityType) {
            const oldTri = gameTriangles[oldTriangleId];
            const newTri = gameTriangles[newTriangleId];

            if (oldTri) {
                oldTri.isWarpingOut = true;
                oldTri.warpingEntityType = entityType; // Wer verlässt das Feld?
                oldTri.warpTime = performance.now();
                setTimeout(() => {
                    oldTri.isWarpingOut = false;
                    oldTri.warpingEntityType = null;
                }, WARP_ANIM_DURATION);
            }

            if (newTri) {
                newTri.isWarpingIn = true;
                newTri.warpingEntityType = entityType; // Wer betritt das Feld?
                newTri.warpTime = performance.now();
                 setTimeout(() => {
                    newTri.isWarpingIn = false;
                    newTri.warpingEntityType = null;
                }, WARP_ANIM_DURATION);
            }
        }


        async function movePlayerTo(targetId) { 
            if (gameOver || !gameActive || playerTriangleId === -1 || !gameTriangles[targetId]) return false; 
            if (Tone) await ensureAudioContextStarted(); 
            
            const potentialTargetTriangle = gameTriangles[targetId];

            if (potentialTargetTriangle.occupant && potentialTargetTriangle.occupant.startsWith('ENEMY')) {
                await handleLifeLost(playerTriangleId); 
                return false; 
            }
            
            const oldPlayerTriangleId = playerTriangleId; 
            if (gameTriangles[oldPlayerTriangleId]) {
                gameTriangles[oldPlayerTriangleId].occupant = null; // Altes Feld freigeben
            }
            
            playerTriangleId = targetId; 
            gameTriangles[targetId].occupant = 'PLAYER'; // Neues Feld besetzen
            
            await moveEntityVisuals(oldPlayerTriangleId, targetId, 'PLAYER');

            const newPlayerTriangle = gameTriangles[playerTriangleId];
            handlePlayerInteraction(newPlayerTriangle); // Interaktion mit dem Typ des neuen Feldes

            if (newPlayerTriangle.center) { 
                const targetDir = newPlayerTriangle.center.clone().normalize();
                targetSphereQuaternion.setFromUnitVectors(new THREE.Vector3(0,0,1), targetDir).invert();
            }

            playSound(moveSynth, "E4", "32n"); 
            updateInfoPanel(); 
            return true; 
        }

        function handlePlayerInteraction(triangle) {
            if (gameOver || !gameActive || !triangle) return; 
            switch (triangle.type) { 
                case 'KEY': 
                    window.playerKeysHeld++; 
                    playSound(keyPickupSynth, ["C5", "E5", "A5"], "16n"); 
                    triangle.type = 'EMPTY'; // Schlüssel wird zu einem leeren Feld, nachdem er aufgenommen wurde
                    updateInfoPanel();
                    break;
                case 'CHEST': 
                    if (_playerKeysHeld > 0) { 
                        window.keysDelivered += _playerKeysHeld; 
                        window.playerKeysHeld = 0; 
                        triangle.isUsedChest = true; 
                        playSound(chestDeliverySynth, null); 
                        
                        if (_keysDelivered >= _numKeys) {
                        }
                        updateInfoPanel();
                    } else { 
                        playSound(errorSynth, null, "16n"); 
                    }
                    break;
                case 'EXIT': 
                    if (_keysDelivered >= _numKeys) { 
                        playSound(winSynth, ["C4", "E4", "G4", "C5"], "2n"); 
                        gameOver = true; 
                    } else { 
                        playSound(errorSynth, null, "8n"); 
                    }
                    break;
            }
        }
        
        function findShortestPath(startId, endId) {
            if (!gameTriangles[startId] || !gameTriangles[endId]) return []; 
            const queue = [[startId, [startId]]]; 
            const visited = new Set([startId]); 

            while (queue.length > 0) {
                const [currentId, path] = queue.shift(); 
                if (currentId === endId) return path.slice(1); 
                
                const currentTriangle = gameTriangles[currentId];
                if (!currentTriangle || !currentTriangle.neighbors) continue; 

                for (const neighborId of currentTriangle.neighbors) {
                    if (!visited.has(neighborId)) { 
                        const neighborTriangle = gameTriangles[neighborId];
                        // Pfadfindung meidet Wände und Felder, die von Gegnern besetzt sind
                        if (neighborTriangle && neighborTriangle.type !== 'WALL' && (!neighborTriangle.occupant || !neighborTriangle.occupant.startsWith('ENEMY'))) { 
                            visited.add(neighborId); 
                            const newPath = [...path, neighborId]; 
                            queue.push([neighborId, newPath]); 
                        }
                    }
                }
            }
            return []; 
        }

        function highlightPath(path) {
            clearPathHighlight(); 
            path.forEach(triId => {
                if (gameTriangles[triId]) {
                    gameTriangles[triId].isPathSegment = true;
                }
            });
        }

        function clearPathHighlight() {
            let needsUpdate = false;
            gameTriangles.forEach(tri => {
                if (tri.isPathSegment) {
                    tri.isPathSegment = false;
                    needsUpdate = true;
                }
            });
        }

        async function startAutoMove(path) { 
            if (gameOver || !gameActive || !path || path.length === 0) return;
            autoMovePath = [...path]; 
            isAutoMoving = true;
            
            highlightPath(autoMovePath); 
            if (Tone) await ensureAudioContextStarted();
            playSound(pathStartSynth, "A4", "16n");
            nextAutoMoveTime = performance.now() + PATH_HIGHLIGHT_DURATION; 
        }

        async function processAutoMove() { 
            if (gameOver || !gameActive || !isAutoMoving || autoMovePath.length === 0) {
                if (isAutoMoving) { 
                    isAutoMoving = false;
                    clearPathHighlight(); 
                }
                return;
            }

            const currentTime = performance.now();
            if (currentTime >= nextAutoMoveTime) { 
                const nextStepId = autoMovePath.shift(); 
                if (typeof nextStepId === 'undefined') { 
                    isAutoMoving = false;
                    clearPathHighlight();
                    return;
                }
                
                const moveSuccessful = await movePlayerTo(nextStepId); 
                
                if (moveSuccessful) {
                    lastPlayerMoveTime = currentTime; 
                    if (autoMovePath.length === 0) { 
                        isAutoMoving = false;
                        clearPathHighlight(); 
                    } else { 
                        nextAutoMoveTime = currentTime + PLAYER_MOVE_COOLDOWN;
                    }
                } else { 
                    isAutoMoving = false;
                    autoMovePath = []; 
                    clearPathHighlight();
                }
            }
        }
        
        function chooseNewEnemyFacingDirection(enemy, isInitial = false, collidedWithWall = false) {
            const currentTri = gameTriangles[enemy.currentTriangleId];
            if (!currentTri || !currentTri.neighbors || currentTri.neighbors.length === 0) {
                enemy.currentFacingDirectionId = null;
                return;
            }

            let possibleMoves = currentTri.neighbors.filter(nId => {
                const neighborTri = gameTriangles[nId];
                return neighborTri && neighborTri.type !== 'WALL' && nId !== enemy.currentTriangleId && // Nicht das aktuelle Feld
                       (!neighborTri.occupant || neighborTri.occupant === 'PLAYER'); // Nicht von anderem Gegner besetzt (Spieler ist ok für Kollision)
            });

            if ((collidedWithWall || !isInitial) && enemy.previousMoveFromId !== null && possibleMoves.length > 1) {
                possibleMoves = possibleMoves.filter(nId => nId !== enemy.previousMoveFromId);
            }
            
            if (possibleMoves.length > 0) {
                enemy.currentFacingDirectionId = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
            } else { // Fallback, wenn alle "guten" Züge blockiert sind
                 const fallbackMoves = currentTri.neighbors.filter(nId => gameTriangles[nId] && gameTriangles[nId].type !== 'WALL' && nId !== enemy.currentTriangleId);
                 if (fallbackMoves.length > 0) {
                    enemy.currentFacingDirectionId = fallbackMoves[Math.floor(Math.random() * fallbackMoves.length)];
                 } else {
                    enemy.currentFacingDirectionId = null; 
                 }
            }
        }

        function updateEnemyArrow(enemy) {
            if (!enemy.directionArrow || enemy.currentFacingDirectionId === null || 
                !gameTriangles[enemy.currentTriangleId] || !gameTriangles[enemy.currentFacingDirectionId]) {
                if(enemy.directionArrow) enemy.directionArrow.visible = false;
                return;
            }

            const currentEnemyTri = gameTriangles[enemy.currentTriangleId];
            const nextTargetTri = gameTriangles[enemy.currentFacingDirectionId]; 

            const arrowPosition = nextTargetTri.center.clone().add(nextTargetTri.normal.clone().multiplyScalar(0.03)); // Leicht über der Oberfläche des ZIEL-Dreiecks
            enemy.directionArrow.position.copy(arrowPosition);
            
            const directionToNext = new THREE.Vector3().subVectors(nextTargetTri.center, currentEnemyTri.center).normalize(); 
            
            const yAxis = directionToNext; // Pfeilspitze in Bewegungsrichtung
            const zAxis = nextTargetTri.normal.clone(); // Pfeil flach auf Oberfläche des ZIEL-Dreiecks
            const xAxis = new THREE.Vector3().crossVectors(yAxis, zAxis).normalize();
            
            // Sicherstellen, dass yAxis senkrecht zu zAxis steht, falls sie es nicht schon sind
            const correctedYAxis = new THREE.Vector3().crossVectors(zAxis, xAxis).normalize();

            const matrix = new THREE.Matrix4();
            matrix.makeBasis(xAxis, correctedYAxis, zAxis);
            enemy.directionArrow.quaternion.setFromRotationMatrix(matrix);
            
            enemy.directionArrow.visible = true;
        }


        async function moveEnemies() { 
            if (gameOver || !gameActive ) return; 
            const currentTime = performance.now();

            for (const enemy of enemies) { 
                if (currentTime - enemy.lastMoveTime < ENEMY_MOVE_COOLDOWN) continue; 

                const oldEnemyTriangleId = enemy.currentTriangleId; 
                const currentEnemyTriangle = gameTriangles[oldEnemyTriangleId];
                
                let targetThisTurnId = enemy.currentFacingDirectionId;

                // 1. Wenn keine Richtung oder Ziel ist Wand -> neue Richtung wählen
                if (targetThisTurnId === null || !gameTriangles[targetThisTurnId] || gameTriangles[targetThisTurnId].type === 'WALL') {
                    enemy.previousMoveFromId = oldEnemyTriangleId; 
                    chooseNewEnemyFacingDirection(enemy, false, true); // true für Wandkollision
                    targetThisTurnId = enemy.currentFacingDirectionId; 
                    
                    if (targetThisTurnId === null || !gameTriangles[targetThisTurnId] || gameTriangles[targetThisTurnId].type === 'WALL') {
                        enemy.lastMoveTime = currentTime; 
                        updateEnemyArrow(enemy); 
                        continue; 
                    }
                }

                const targetTriangleForThisTurn = gameTriangles[targetThisTurnId];

                // 2. Prüfen, ob das Ziel von einem anderen Gegner besetzt ist
                if (targetTriangleForThisTurn.occupant && targetTriangleForThisTurn.occupant.startsWith('ENEMY')) {
                    enemy.previousMoveFromId = oldEnemyTriangleId; 
                    chooseNewEnemyFacingDirection(enemy, false, false); // Wähle eine neue zufällige Richtung
                    updateEnemyArrow(enemy); 
                    enemy.lastMoveTime = currentTime;
                    continue; 
                }
                
                // 3. Bewege den Gegner zum Ziel (kann auch Spielerfeld sein)
                if (gameTriangles[oldEnemyTriangleId]) {
                    gameTriangles[oldEnemyTriangleId].occupant = null;
                }
                enemy.currentTriangleId = targetThisTurnId; 
                gameTriangles[targetThisTurnId].occupant = `ENEMY_${enemy.id}`;
                await moveEntityVisuals(oldEnemyTriangleId, targetThisTurnId, 'ENEMY'); 

                // 4. Kollision mit Spieler nach der Bewegung
                if (enemy.currentTriangleId === playerTriangleId && playerTriangleId !== -1) { 
                    await handleLifeLost(playerTriangleId); 

                    if (!gameOver) { 
                        if(gameTriangles[playerTriangleId] && playerTriangleId !== -1) gameTriangles[playerTriangleId].occupant = null; // Spieler vom Kollisionsfeld nehmen
                        
                        playerTriangleId = startLocationId; 
                        if(gameTriangles[playerTriangleId]) {
                            gameTriangles[playerTriangleId].occupant = 'PLAYER'; 
                            const playerStartTri = gameTriangles[playerTriangleId];
                            if (playerStartTri && playerStartTri.center) {
                                const targetDir = playerStartTri.center.clone().normalize();
                                targetSphereQuaternion.setFromUnitVectors(new THREE.Vector3(0,0,1), targetDir).invert();
                            }
                        }
                    }
                }
                
                // 5. Bestimme die Ausrichtung für den NÄCHSTEN Zug (versuche geradeaus)
                const newCurrentTri = gameTriangles[enemy.currentTriangleId]; 
                const prevTriForDirection = gameTriangles[oldEnemyTriangleId]; 

                let bestNextFacingId = null;
                if (newCurrentTri && prevTriForDirection && newCurrentTri.neighbors && enemy.currentTriangleId !== oldEnemyTriangleId) { 
                    const moveVector = new THREE.Vector3().subVectors(newCurrentTri.center, prevTriForDirection.center).normalize();
                    let maxDot = -0.5; 

                    for (const neighborId of newCurrentTri.neighbors) {
                        if (neighborId === oldEnemyTriangleId) continue; 
                        const neighborTri = gameTriangles[neighborId];
                        if (neighborTri && neighborTri.type !== 'WALL') { 
                            const dirToNeighbor = new THREE.Vector3().subVectors(neighborTri.center, newCurrentTri.center).normalize();
                            const dot = moveVector.dot(dirToNeighbor);
                            if (dot > maxDot) {
                                maxDot = dot;
                                bestNextFacingId = neighborId;
                            }
                        }
                    }
                }
                
                if (bestNextFacingId !== null) {
                    enemy.currentFacingDirectionId = bestNextFacingId;
                } else {
                    enemy.previousMoveFromId = enemy.currentTriangleId; 
                    chooseNewEnemyFacingDirection(enemy, false, false); 
                }

                updateEnemyArrow(enemy);
                enemy.lastMoveTime = currentTime; 
            } 
        }

        // Aktualisiert die Textanzeigen im Info-Panel
        function updateInfoPanel() {
            document.getElementById('livesInfo').textContent = `Leben: ${playerLives} / ${MAX_PLAYER_LIVES}`;
            document.getElementById('keysInfo').textContent = `Schlüssel: ${_playerKeysHeld} | Ziel: ${_numKeys}`; 
            document.getElementById('chestsInfo').textContent = `Abgelegt: ${_keysDelivered} / ${_numChests}`;
        }

        // Haupt-Animationsschleife des Spiels
        async function animate() { 
            requestAnimationFrame(animate); 

            const currentTime = performance.now();

            if (ambientLight) {
                const intensityPulse = (Math.sin(currentTime * 0.0005) + 1) / 2 * 0.3 + 0.5; 
                ambientLight.intensity = intensityPulse;
            }
            
            if (!gameOver) {
                 updateTriangleColors(hoveredTriangleId, gameActive && hoveredTriangleId !== -1);
            }


            if (sphereGroup && !sphereGroup.quaternion.equals(targetSphereQuaternion)) { 
                sphereGroup.quaternion.slerp(targetSphereQuaternion, 0.07); 
            }
            
            if (gameActive && !gameOver) { 
                if (isAutoMoving) {
                    await processAutoMove(); 
                }
                await moveEnemies(); 
            }
            
            if (renderer && scene && camera) { 
                renderer.render(scene, camera);
            }
        }

        // Startet die Initialisierung des Spiels und fängt mögliche Fehler ab
        try {
            init(); 
        } catch (error) {
            console.error("Fehler während der Initialisierung des Spiels:", error);
            const body = document.querySelector('body');
            if (body) { // Fallback-Fehlermeldung für den Benutzer
                body.innerHTML = '<div style="color: red; padding: 20px; text-align: center; font-size: 1.2em;">Ein Fehler ist beim Laden des Spiels aufgetreten. Bitte überprüfen Sie die Browser-Konsole für Details.</div>';
            }
        }
    </script>
</body>
</html>
